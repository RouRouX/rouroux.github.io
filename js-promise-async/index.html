<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="异步Promise及Async/Await最完整入门攻略"><meta name="keywords" content="javascript,promise,async/await"><meta name="author" content="RouRouX"><meta name="copyright" content="RouRouX"><title>异步Promise及Async/Await最完整入门攻略 | RouRouX's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"9OG6L2Y72Y","apiKey":"4044bc352f3b75cee6146e503714e88c","indexName":"hexo-blog-search","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89Async-Await%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">为什么有Async&#x2F;Await？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">Promise简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.</span> <span class="toc-text">Promise实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E7%9A%84then%E5%92%8Ccatch"><span class="toc-number">2.2.</span> <span class="toc-text">Promise的then和catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E7%9B%B8%E4%BA%92%E4%BE%9D%E8%B5%96"><span class="toc-number">2.3.</span> <span class="toc-text">Promise相互依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E9%93%BE%E5%BC%8F%E5%86%99%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">Promise链式写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%86%99%E6%B3%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">2.5.</span> <span class="toc-text">链式写法需要注意的地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%86%99%E6%B3%95%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">链式写法的错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E9%93%BE%E5%BC%8F%E4%B8%AD%E9%97%B4%E6%83%B3%E8%BF%94%E5%9B%9E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%80%BC"><span class="toc-number">2.7.</span> <span class="toc-text">Promise链式中间想返回自定义的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E6%88%96%E5%81%9C%E6%AD%A2Promise%E9%93%BE%E5%BC%8F"><span class="toc-number">2.8.</span> <span class="toc-text">如何跳出或停止Promise链式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-all"><span class="toc-number">2.9.</span> <span class="toc-text">Promise.all</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Async-await%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">Async&#x2F;await介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EPromise%E7%9A%84Async-await"><span class="toc-number">3.1.</span> <span class="toc-text">基于Promise的Async&#x2F;await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.2.</span> <span class="toc-text">async的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BE%8B%E5%AD%90"><span class="toc-number">3.3.</span> <span class="toc-text">await的本质与例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await-%E4%BC%98%E5%8A%BF%E5%AE%9E%E6%88%98"><span class="toc-number">3.4.</span> <span class="toc-text">async&#x2F;await 优势实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">async&#x2F;await错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await%E7%9A%84%E4%B8%AD%E6%96%AD%EF%BC%88%E7%BB%88%E6%AD%A2%E7%A8%8B%E5%BA%8F%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">async&#x2F;await的中断（终止程序）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%B8%AD%E5%BC%82%E6%AD%A5%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">4.</span> <span class="toc-text">实战中异步需要注意的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-%E4%B8%B2%E8%A1%8C-%E4%B9%8Bthen%E5%86%99%E6%B3%95%E6%B3%A8%E6%84%8F"><span class="toc-number">4.1.</span> <span class="toc-text">Promise获取数据(串行)之then写法注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E5%BE%AA%E7%8E%AF%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-%E4%B8%B2%E8%A1%8C-%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.</span> <span class="toc-text">Promise循环获取数据(串行)之for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await%E5%BE%AA%E7%8E%AF%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-%E4%B8%B2%E8%A1%8C-%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.3.</span> <span class="toc-text">async&#x2F;await循环获取数据(串行)之for循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">5.</span> <span class="toc-text">后记</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/RouRouX/store/img/avatat.jpg"></div><div class="author-info__name text-center">RouRouX</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/RouRouX">github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://hub.docker.com/u/rouroux">docker</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/RouRouX/store/img/20200601011404.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">RouRouX's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">异步Promise及Async/Await最完整入门攻略</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javascript/">javascript</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">8.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 31 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>全文转载自 <a target="_blank" rel="noopener" href="https://www.tangyida.top/detail/152">https://www.tangyida.top/detail/152</a>  作者：唐益达  </p>
<p>除修正原文中的错别字和部分代码（文中有说明）其余未修改</p>
</blockquote>
<blockquote>
<p>此文只介绍Async/Await与Promise基础知识与实际用到注意的问题，将通过很多代码实例进行说明。</p>
</blockquote>
<h2 id="为什么有Async-Await？"><a href="#为什么有Async-Await？" class="headerlink" title="为什么有Async/Await？"></a>为什么有Async/Await？</h2><p>我们都知道已经有了<code>Promise</code>的解决方案了，为什么还要ES7提出新的Async/Await标准呢？</p>
<p>答案其实也显而易见：<code>Promise</code>虽然跳出了异步嵌套的怪圈，用链式表达更加清晰，但是我们也发现如果有大量的异步请求的时候，流程复杂的情况下，会发现充满了屏幕的<code>then</code>，看起来非常吃力，而ES7的Async/Await的出现就是为了解决这种复杂的情况。</p>
<p>首先，我们必须了解<code>Promise</code>。</p>
<span id="more"></span>

<h2 id="Promise简介"><a href="#Promise简介" class="headerlink" title="Promise简介"></a>Promise简介</h2><h3 id="Promise实例"><a href="#Promise实例" class="headerlink" title="Promise实例"></a>Promise实例</h3><p>什么是Promise，很多人应该都知道基础概念？直接看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setDelay = <span class="function">(<span class="params">millisecond</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> millisecond != <span class="string">&#x27;number&#x27;</span>) reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;参数必须是number类型&#x27;</span>));</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">`我延迟了<span class="subst">$&#123;millisecond&#125;</span>毫秒后输出的`</span>)</span><br><span class="line">      &#125;, millisecond)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把一个Promise封装在一个函数里面同时返回了一个Promise，这样比较规范。</p>
<p>可以看到定义的Promise有两个参数，<code>resolve</code>和<code>reject</code>。</p>
<ul>
<li><code>resolve</code>：将异步的执行从<code>pending(请求)</code>变成了<code>resolve(成功返回)</code>，是个函数执行返回。</li>
<li><code>reject</code>：顾名思义“拒绝”，就是从请求变成了”失败”，是个函数可以执行返回一个结果，但我们这里推荐大家返回一个错误<code>new Error()</code>。</li>
</ul>
<blockquote>
<p>上述例子，你可以<code>reject(&#39;返回一个字符串&#39;)</code>，随便你返回，但是我们还是<strong>建议返回一个Error对象，这样更加清晰是“失败的”，这样更规范一点</strong>。</p>
</blockquote>
<h3 id="Promise的then和catch"><a href="#Promise的then和catch" class="headerlink" title="Promise的then和catch"></a>Promise的then和catch</h3><p>我们通过Promise的原型方法<code>then</code>拿到我们的返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="number">2000</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result) <span class="comment">// 输出“我延迟了2000毫秒后输出的”</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出下列的值：“我延迟了2000毫秒后输出的”。</p>
<p>如果出错呢？那就用<code>catch</code>捕获：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="string">&#x27;我是字符串&#x27;</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result) <span class="comment">// 不进去了</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err) <span class="comment">// 输出错误：“参数必须是number类型”</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>是不是很简单？好，现在我增加一点难度，如果多个<code>Promise</code>执行会是怎么样呢？</p>
<h3 id="Promise相互依赖"><a href="#Promise相互依赖" class="headerlink" title="Promise相互依赖"></a>Promise相互依赖</h3><p>我们在写一个Promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setDelaySecond = <span class="function">(<span class="params">seconds</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> seconds != <span class="string">&#x27;number&#x27;</span> || seconds &gt; <span class="number">10</span>) reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;参数必须是number类型，并且小于等于10&#x27;</span>));</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`先是setDelaySeconds函数输出，延迟了<span class="subst">$&#123;seconds&#125;</span>秒，一共需要延迟<span class="subst">$&#123;seconds+<span class="number">2</span>&#125;</span>秒`</span>)</span><br><span class="line">        resolve(setDelay(<span class="number">2000</span>)) <span class="comment">// 这里依赖上一个Promise</span></span><br><span class="line">      &#125;, seconds * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下一个需要依赖的<code>resolve</code>去返回另一个Promise，会发生什么呢？我们执行一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelaySecond(<span class="number">3</span>).then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你会发现结果是先执行：<strong>“先是setDelaySeconds输出，延迟了2秒，一共需要延迟5秒”</strong></p>
<p>再执行<code>setDelay</code>的<code>resolve</code>：<strong>“我延迟了2000毫秒后输出的”</strong>。的确做到了依次执行的目的。</p>
<p>有人说，我不想耦合性这么高，想先执行<code>setDelay</code>函数再执行<code>setDelaySecond</code>，但不想用上面那种写法，可以吗，答案是当然可以。</p>
<h3 id="Promise链式写法"><a href="#Promise链式写法" class="headerlink" title="Promise链式写法"></a>Promise链式写法</h3><p>先改写一下<code>setDelaySecond</code>，拒绝依赖，降低耦合性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setDelaySecond = <span class="function">(<span class="params">seconds</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> seconds != <span class="string">&#x27;number&#x27;</span> || seconds &gt; <span class="number">10</span>) reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;参数必须是number类型，并且小于等于10&#x27;</span>));</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">`我延迟了<span class="subst">$&#123;seconds&#125;</span>秒后输出的，是第二个函数`</span>)</span><br><span class="line">      &#125;, seconds * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先执行<code>setDelay</code>在执行<code>setDelaySecond</code>，只需要在第一个<code>then</code>的结果中<strong>返回下一个Promise就可以一直链式写下去了，相当于依次执行</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="number">2000</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第一步的&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> setDelaySecond(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第二步的&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>发现确实达到了可喜的链式（终于脱离异步嵌套苦海，哭），可以看到<code>then</code>的链式写法非常优美。</p>
<h3 id="链式写法需要注意的地方"><a href="#链式写法需要注意的地方" class="headerlink" title="链式写法需要注意的地方"></a>链式写法需要注意的地方</h3><p>这里一定要提到一点：</p>
<p><code>then</code>式链式写法的本质其实是一直<strong>往下传递返回一个新的Promise</strong>，也就是说<strong>then在下一步接收的是上一步返回的Promise</strong>，理解这个对于后面的细节非常重要！！</p>
<p>那么并不是这么简单，then的返回我们可以看出有2个参数(都是回调)：</p>
<ul>
<li>第一个回调是resolve的回调，也就是第一个参数用得最多，拿到的是上一步的<code>Promise</code>成功<code>resolve</code>的值。</li>
<li>第二个回调是reject的回调，用的不多，但是求求大家不要写错了，通常是拿到上一个的错误，那么这个错误处理和catch有什么区别和需要注意的地方呢？</li>
</ul>
<p>我们修改上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="number">2000</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第一步的&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> setDelaySecond(<span class="number">20</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第二步的&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;, <span class="function">(<span class="params">_err</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我出错啦，进到这里捕获错误，但是不经过catch了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我还是继续执行的！！！！&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到输出结果是：进到了<code>then</code>的第二个参数（reject）中去了，而且最重要的是！不再经过<code>catch</code>了。</p>
<p>那么我们把catch挪上去，写到<code>then</code>错误处理前：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="number">2000</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第一步的&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> setDelaySecond(<span class="number">20</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123; <span class="comment">// 挪上去了</span></span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 这里catch到上一个返回Promise的错误</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第二步的&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;, <span class="function">(<span class="params">_err</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我出错啦，但是由于catch在我前面，所以错误早就被捕获了，我这没有错误了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我还是继续执行的！！！！&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到先经过<code>catch</code>的捕获，后面就没错误了。</p>
<p>可以得出需要注意的：</p>
<ul>
<li><code>catch</code>写法是针对于整个链式写法的错误捕获的，而<code>then</code>第二个参数是针对于上一个返回<code>Promise</code>的。</li>
<li>两者的优先级：就是<strong>看谁在链式写法的前面</strong>，在前面的先捕获到错误，后面就没有错误可以捕获了，链式前面的优先级大，而且两者都不是<code>break</code>， 可以继续执行后续操作不受影响。</li>
</ul>
<h3 id="链式写法的错误处理"><a href="#链式写法的错误处理" class="headerlink" title="链式写法的错误处理"></a>链式写法的错误处理</h3><p>上述已经写好了关于then里面三个回调中第二个回调（reject）会与catch冲突的问题，那么我们实际写的时候，参数捕获的方式基本写得少，catch的写法会用到更多。</p>
<p>既然有了很多的Promise，那么我需不需要写很多catch呢？</p>
<p>答案当然是：<strong>不需要！</strong>，哪有那么麻烦的写法，只需要在末尾<code>catch</code>一下就可以了，因为链式写法的错误处理具有“冒泡”特性，<strong>链式中任何一个环节出问题，都会被<code>catch</code>到，同时在某个环节后面的代码就不会执行了</strong>。</p>
<p>既然说到这里，我们把<code>catch</code>移到第一个链式的返回里面会发生什么事呢？看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="string">&#x27;2000&#x27;</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;第一步完成了&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="keyword">return</span> setDelaySecond(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123; <span class="comment">// 这里移到第一个链式去，发现上面的不执行了，下面的继续执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;第二步完成了&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>惊喜的发现，<strong>链式继续走下去了</strong>！！输出如下（undefined是因为上一个then没有返回一个Promise）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/RouRouX/store/img/20200629125344.png" alt="img"></p>
<p>重点来了！敲黑板！！<strong>链式中的<code>catch</code>并不是终点！！catch完如果还有then还会继续往下走！不信的话可以把第一个<code>catch</code>在最后面的那个例子后面再加几个<code>then</code>，你会发现并不会跳出链式执行</strong>。</p>
<p>如果顺序执行<code>setDelay，setDelay1,setDelaySecond</code>，按照上述的逻辑，流程图可以概括如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/RouRouX/store/img/20200629125354.png" alt="img"></p>
<p><code>catch</code>只是捕获错误的一个链式表达，并不是break！</p>
<p>所以，<strong>catch放的位置也很有讲究</strong>，一般放在一些重要的、必须catch的程序的最后。<strong>这些重要的程序中间一旦出现错误，会马上跳过其他后续程序的操作直接执行到最近的catch代码块，但不影响catch后续的操作</strong>！！！！</p>
<p>到这就不得不体一个ES2018标准新引入的**Promise的<code>finally</code>**，表示在catch后必须肯定会默认执行的的操作。这里不多展开，细节可以参考：<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise#Promise-prototype-finally">Promise的finally</a></p>
<h3 id="Promise链式中间想返回自定义的值"><a href="#Promise链式中间想返回自定义的值" class="headerlink" title="Promise链式中间想返回自定义的值"></a>Promise链式中间想返回自定义的值</h3><p>其实很简单，用<code>Promise</code>的原型方法<code>resolve</code>即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="number">2000</span>).then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;第一步完成了&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="keyword">let</span> message = <span class="string">&#x27;这是我自己想处理的值&#x27;</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(message) <span class="comment">// 这里返回我想在下一阶段处理的值</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;第二步完成了&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 这里拿到上一阶段的返回值</span></span><br><span class="line">  <span class="comment">//return Promise.resolve(&#x27;这里可以继续返回&#x27;)</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="如何跳出或停止Promise链式"><a href="#如何跳出或停止Promise链式" class="headerlink" title="如何跳出或停止Promise链式"></a>如何跳出或停止Promise链式</h3><p>不同于一般的<code>function</code>的<code>break</code>的方式，如果你是这样的操作：<code>func().then().then().then().catch()</code>的方式，你想在第一个<code>then</code>就跳出链式，后面的不想执行了，不同于一般的<code>break;return null;return false</code>等操作，可以说，如何停止Promise链，是一大难点，是整个Promise最复杂的地方。</p>
<p><strong>1.用链式的思维想，我们拒绝掉某一链，那么不就是相当于直接跳到了catch模块吗？</strong></p>
<p>我们是不是可以直接“拒绝“掉达到停止的目的？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="number">2000</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第一步的&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> setDelaySecond(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第二步的&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我主动跳出循环了&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;跳出循环的信息&#x27;</span>) <span class="comment">// 这里返回一个reject,主动跳出循环了</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我不执行&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">mes</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(mes)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我跳出了&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是很容易看到缺点：有时候你并不确定是因为错误跳出的，还是主动跳出的，所以我们可以加一个标志位：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(&#123;</span><br><span class="line">    <span class="attr">isNotErrorExpection</span>: <span class="literal">true</span> <span class="comment">// 返回的地方加一个标志位，判断是否是错误类型，如果不是，那么说明可以是主动跳出循环的</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>或者根据上述的代码判断catch的地方输出的类型是不是属于错误对象的，是的话说明是错误，不是的话说明是主动跳出的，你可以自己选择（这就是为什么要统一错误reject的时候输出new Error(‘错误信息’)的原因，规范！）</p>
<p>当然你也可以直接抛出一个错误跳出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;错误信息&#x27;</span>) <span class="comment">// 直接跳出，那就不能用判断是否为错误对象的方法进行判断了</span></span><br></pre></td></tr></table></figure>

<p><strong>2.那有时候我们有这个需求：catch是放在中间（不是末尾），上述方法中止后catch后面的代码继续执行，而同时我们又不想执行catch后面的代码，也就是链式的绝对中止，应该怎么办？</strong></p>
<p>我们看这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="number">2000</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第一步的&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> setDelaySecond(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第二步的&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我主动跳出循环了&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;跳出循环的信息&#x27;</span>) <span class="comment">// 这里直接调用Promise原型方法返回一个reject,主动跳出循环了</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我不执行&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">mes</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(mes)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我跳出了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我不想执行，但是却执行了&#x27;</span>); <span class="comment">// 问题在这，上述的终止方法治标不治本。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这时候最后一步<code>then</code>还是执行了，整条链都其实没有本质上的跳出，那应该怎么办呢？</p>
<p><strong>敲黑板！重点来了</strong>！！我们看<a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promise/A+</a>规范可以知道：</p>
<blockquote>
<p>A promise must be in one of three states: pending, fulfilled, or rejected.</p>
</blockquote>
<p>Promise其实是有三种状态的：<strong>pending，resolve，rejected</strong>，那么我们一直在讨论<code>resolve和rejected</code>这2个状态，是不是忽视了<code>pending</code>这个状态呢？pending状态顾名思义就是请求中的状态，成功请求就是resolve，失败就是reject，其实他就是个中间过渡状态。</p>
<p>而我们上面讨论过了，**<code>then</code>的下一层级其实得到的是上一层级返回的Promise对象，也就是说原Promise对象与新对象状态保持一致**。那么重点来了，如果你想在这一层级进行终止，是不是直接让它永远都<code>pending</code>下去，那么后续的操作不就没了吗？是不是就达到这个目的了？？觉得有疑问的可以参考<a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promise/A+</a>规范。</p>
<p>我们直接看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="number">2000</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我进行到第一步的&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> setDelaySecond(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我主动跳出循环了&#x27;</span>);</span><br><span class="line">  <span class="comment">// return Promise.reject(&#x27;跳出循环的信息&#x27;)</span></span><br><span class="line">  <span class="comment">// 重点在这</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;后续的不会执行&#x27;</span>)&#125;) <span class="comment">// 这里返回的一个新的Promise，没有resolve和reject，那么会一直处于pending状态，因为没返回啊，那么这种状态就一直保持着，中断了这个Promise</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我不执行&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">mes</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(mes)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我跳出了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我也不会执行&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样就解决了上述，错误跳出而导致无法完全终止Promise链的问题。</p>
<p>但是！随之而来也有一个问题，那就是可能会导致<strong>潜在的内存泄漏</strong>，因为我们知道这个一直处于pending状态下的Promise会一直处于被挂起的状态，而我们具体不知道浏览器的机制细节也不清楚，一般的网页没有关系，但大量的复杂的这种pending状态势必会导致内存泄漏，具体的没有测试过，后续可能会跟进测试（nodeJS或webapp里面不推荐这样），而我通过查询也难以找到答案，这篇文章可以推荐看一下：<a target="_blank" rel="noopener" href="https://github.com/xieranmaya/blog/issues/5">从如何停掉 Promise 链说起</a>。可能对你有帮助在此种情况下如何做。</p>
<p>当然一般情况下是不会存在泄漏，只是有这种风险，无法取消Promise一直是它的痛点。而上述两个奇妙的取消方法要具体情形具体使用。</p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>其实这几个方法就简单了，就是一个简写串联所有你需要的<code>Promise</code>执行，具体可以参照<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise#Promise-all">阮一峰的ES6Promise.all教程</a>。</p>
<p>我这上一个代码例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([setDelay(<span class="number">1000</span>), setDelaySecond(<span class="number">1</span>)]).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出[&quot;我延迟了1000毫秒后输出的&quot;, &quot;我延迟了1秒后输出的，注意单位是秒&quot;]</span></span><br></pre></td></tr></table></figure>

<p>输出的是一个数组，相当于把<code>all</code>方法里面的<code>Promise</code>链式执行，同时把resolve的值保存在数组中输出。类似的还有<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise#Promise-race">Promise.race</a>这里就不多赘述了。</p>
<h2 id="Async-await介绍"><a href="#Async-await介绍" class="headerlink" title="Async/await介绍"></a>Async/await介绍</h2><h3 id="基于Promise的Async-await"><a href="#基于Promise的Async-await" class="headerlink" title="基于Promise的Async/await"></a>基于Promise的Async/await</h3><p>什么是<code>async/await</code>呢？可以总结为一句话：<strong>async/await是一对好基友，缺一不可，他们的出生是为Promise服务的</strong>。可以说async/await是Promise的爸爸，进化版。为什么这么说呢？且听我细细道来。</p>
<p>为什么要有<code>async/await</code>存在呢？</p>
<p>前文已经说过了，为了解决大量复杂不易读的Promise异步的问题，才出现的改良版。</p>
<p><strong>这两个基友必须同时出现，缺一不可</strong>，那么先说一下<code>Async</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面可以看出，**<code>async</code>必须声明的是一个function**，不要去声明别的，要是那样<code>await</code>就不理你了（报错）。</p>
<p>这样声明也是错的！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">async</span> demo =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>必须紧跟着<code>function</code>。接下来说一下它的兄弟<code>await</code>。</p>
<p>上面说到必须是个函数（function），<strong>那么<code>await</code>就必须是在这个<code>async</code>声明的函数内部使用</strong>，否则就会报错。</p>
<p>就算你这样写，也是错的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">&#x27;data&#x27;</span></span><br><span class="line">demo  = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">await</span> data</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须是直系（作用域链不能隔代），这样会报错：<code>Uncaught SyntaxError: await is only valid in async function</code>。</p>
<p>讲完了基本规范，我们接下去说一下他们的本质。</p>
<h3 id="async的本质"><a href="#async的本质" class="headerlink" title="async的本质"></a>async的本质</h3><p>敲黑板！！！很重要！<strong>async声明的函数的返回本质上是一个Promise</strong>。</p>
<p>什么意思呢？就是说你只要声明了这个函数是<code>async</code>，那么内部不管你怎么处理，它的返回肯定是个Promise。</p>
<p>看下列例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;我是Promise&#x27;</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 返回是Promise</span></span><br><span class="line"><span class="comment">//Promise &#123;&lt;resolved&gt;: &quot;我是Promise&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>你会发现返回是这个：<code>Promise &#123;&lt;resolved&gt;: &quot;我是Promise&quot;&#125;</code>。</p>
<p>自动解析成<code>Promise.resolve(&#39;我是Promise&#39;);</code></p>
<p>等同于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;我是Promise&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>所以你想像一般<code>function</code>的返回那样，拿到返回值，原来的思维要改改了！你可以这样拿到返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;我是Promise&#x27;</span>);</span><br><span class="line">    <span class="comment">// 等同于 return &#x27;我是Promise&#x27;</span></span><br><span class="line">    <span class="comment">// 等同于 return new Promise((resolve,reject)=&gt;&#123; resolve(&#x27;我是Promise&#x27;) &#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">demo.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result) <span class="comment">// 这里拿到返回值</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>上述三种写法都行，要看注释细节都写在里面了！！像对待Promise一样去对待async的返回值！！！</strong></p>
<p>好的接下去我们看<code>await</code>的干嘛用的.</p>
<h3 id="await的本质与例子"><a href="#await的本质与例子" class="headerlink" title="await的本质与例子"></a>await的本质与例子</h3><p>await的本质是<strong>可以提供等同于”同步效果“的等待异步返回能力的语法糖</strong>。</p>
<p>这一句咋一看很别扭，好的不急，我们从例子开始看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;我延迟了一秒&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我由于上面的程序还没执行完，先不执行“等待一会”&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// demo的返回当做Promise</span></span><br><span class="line">demo().then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;输出&#x27;</span>,result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>await顾名思义就是等待一会</strong>，只要<code>await</code>声明的函数还没有返回，<strong>那么下面的程序是不会去执行的！！！</strong>。这就是字面意义的等待一会（等待返回再去执行）。</p>
<p>那么你到这测试一下，你会发现输出是这个：<code>输出 undefined</code>。这是为什么呢？这也是我想强调的一个地方！！！</p>
<p>你在<code>demo</code>函数里面都没声明返回，哪来的<code>then</code>？所以正确写法是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;我延迟了一秒&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我由于上面的程序还没执行完，先不执行“等待一会”&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// demo的返回当做Promise</span></span><br><span class="line">demo().then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;输出&#x27;</span>,result); <span class="comment">// 输出 我延迟了一秒</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我推荐的写法是带上<code>then</code>，规范一点，当然你没有返回也是没问题的，<code>demo</code>会照常执行。下面这种写法是不带返回值的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;我延迟了一秒&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我由于上面的程序还没执行完，先不执行“等待一会”&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>

<p>所以可以发现，只要你用await声明的异步返回，是必须“等待”到有返回值的时候，代码才继续执行下去。</p>
<p>那事实是这样吗？你可以跑一下这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我延迟了一秒&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我由于上面的程序还没执行完，先不执行“等待一会”&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">demo().then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;输出&#x27;</span>,result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你会发现，输出是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我由于上面的程序还没执行完，先不执行“等待一会”</span><br><span class="line">输出 1</span><br><span class="line">我延迟了一秒</span><br></pre></td></tr></table></figure>

<p>奇怪，并没有await啊？<code>setTimeout</code>是异步啊，问题在哪？问题就在于<code>setTimeout</code>**这是个异步，但是不是<code>Promise</code>**！起不到“等待一会”的作用。</p>
<p>所以更准确的说法应该是<strong>用await声明的Promise异步返回，必须“等待”到有返回值的时候，代码才继续执行下去。</strong></p>
<p><em><strong>请记住await是在等待一个Promise的异步返回</strong></em></p>
<p>当然这种等待的效果只存在于“异步”的情况，await可以用于声明一般情况下的传值吗？</p>
<p>事实是当然可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&#x27;我是声明值&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> message;</span><br><span class="line">    <span class="built_in">console</span>.log(result); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我由于上面的程序还没执行完，先不执行“等待一会”&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">demo().then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;输出&#x27;</span>,result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是声明值</span><br><span class="line">我由于上面的程序还没执行完，先不执行“等待一会”</span><br><span class="line">输出 我是声明值</span><br></pre></td></tr></table></figure>

<p>这里只要注意一点：<code>then</code>的执行总是最后的。</p>
<h3 id="async-await-优势实战"><a href="#async-await-优势实战" class="headerlink" title="async/await 优势实战"></a>async/await 优势实战</h3><p>现在我们看一下实战：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setDelay = <span class="function">(<span class="params">millisecond</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> millisecond != <span class="string">&#x27;number&#x27;</span>) reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;参数必须是number类型&#x27;</span>));</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">`我延迟了<span class="subst">$&#123;millisecond&#125;</span>毫秒后输出的`</span>)</span><br><span class="line">      &#125;, millisecond)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setDelaySecond = <span class="function">(<span class="params">seconds</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> seconds != <span class="string">&#x27;number&#x27;</span> || seconds &gt; <span class="number">10</span>) reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;参数必须是number类型，并且小于等于10&#x27;</span>));</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">`我延迟了<span class="subst">$&#123;seconds&#125;</span>秒后输出的，注意单位是秒`</span>)</span><br><span class="line">      &#125;, seconds * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面两个延时函数（写在上面），比如我想先延时1秒，在延迟2秒，再延时1秒，最后输出“完成”，这个过程，如果用<code>then</code>的写法，大概是这样（嵌套地狱写法出门右拐不送）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setDelay(<span class="number">1000</span>)</span><br><span class="line">.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    <span class="keyword">return</span> setDelaySecond(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    <span class="keyword">return</span> setDelay(<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>咋一看是不是挺繁琐的？如果逻辑多了估计看得更累，现在我们来试一下async/await</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> setDelay(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> setDelaySecond(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> setDelay(<span class="number">1000</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成了&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>看！是不是没有冗余的长长的链式代码，语义化也非常清楚，非常舒服，那么你看到这里，一定还发现了，上面的<code>catch</code>我们是不是没有在async中实现？接下去我们就分析一下async/await如何处理错误？</p>
<h3 id="async-await错误处理"><a href="#async-await错误处理" class="headerlink" title="async/await错误处理"></a>async/await错误处理</h3><p>因为async函数返回的是一个Promise，所以我们可以在外面<code>catch</code>住错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> setDelay(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> setDelaySecond(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> setDelay(<span class="number">1000</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">demo().catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在async函数的<code>catch</code>中捕获错误，当做一个Pormise处理，<strong>同时你不想用这种方法，可以使用<code>try...catch</code>语句：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> setDelay(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> setDelaySecond(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> setDelay(<span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;完成了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">// 这里捕获错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>当然这时候你就不需要在外面<code>catch</code>了。</p>
<p>通常我们的<code>try...catch</code>数量不会太多，几个最多了，<strong>如果太多了，说明你的代码肯定需要重构了，一定没有写得非常好。还有一点就是try…catch通常只用在需要的时候，有时候不需要catch错误的地方就可以不写。</strong></p>
<p>有人会问了，我<code>try...catch</code>好像只能包裹代码块，如果我需要拆分开分别处理，<strong>不想因为一个的错误就整个process都crash掉了</strong>，那么难道我要写一堆<code>try...catch</code>吗？我就是别扭，我就是不想写<code>try...catch</code>怎嘛办？下面有一种很好的解决方案，仅供参考：</p>
<p>我们知道await后面跟着的肯定是一个<code>Promise</code>那是不是可以这样写？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> setDelay(<span class="number">1000</span>).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> setDelaySecond(<span class="number">12</span>).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(result1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> setDelay(<span class="number">1000</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成了&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>这样输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我延迟了1000毫秒后输出的</span><br><span class="line">Error: 参数必须是number类型，并且小于等于10</span><br><span class="line">    at Promise (test4.html:19)</span><br><span class="line">    at new Promise (&lt;anonymous&gt;)</span><br><span class="line">    at setDelaySecond (test4.html:18)</span><br><span class="line">    at test4.html:56</span><br><span class="line">undefined</span><br><span class="line">我延迟了1000毫秒后输出的</span><br><span class="line">完成了</span><br></pre></td></tr></table></figure>

<p>是不是就算有错误，也不会影响后续的操作，是不是很棒？<strong>当然不是，你说这代码也忒丑了吧，乱七八糟的，写得别扭await又跟着catch</strong>。那么我们可以改进一下，封装一下提取错误的代码函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// to function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">to</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="literal">null</span>, data];</span><br><span class="line">   &#125;)</span><br><span class="line">   .catch(<span class="function"><span class="params">err</span> =&gt;</span> [err]); <span class="comment">// es6的返回写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的是一个数组，第一个是错误，第二个是异步结果，使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">   <span class="comment">// es6的写法，返回一个数组(你可以改回es5的写法觉得不习惯的话)，第一个是错误信息，第二个是then的异步返回数据，这里要注意一下重复变量声明可能导致问题（这里举例是全局，如果用let，const，请换变量名）。</span></span><br><span class="line">  [err, result] = <span class="keyword">await</span> to(setDelay(<span class="number">1000</span>)) </span><br><span class="line">   <span class="comment">// 如果err存在就是有错，不想继续执行就抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出现错误，同时我不想执行了&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  [err, result1] = <span class="keyword">await</span> to(setDelaySecond(<span class="number">12</span>))</span><br><span class="line">   <span class="comment">// 还想执行就不要抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">&#x27;出现错误，同时我想继续执行&#x27;</span>, err);</span><br><span class="line">  <span class="built_in">console</span>.log(result1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> setDelay(<span class="number">1000</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成了&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="async-await的中断（终止程序）"><a href="#async-await的中断（终止程序）" class="headerlink" title="async/await的中断（终止程序）"></a>async/await的中断（终止程序）</h3><p>首先我们要明确的是，<code>Promise</code><strong>本身是无法中止的</strong>，<code>Promise</code>本身<strong>只是一个状态机</strong>，存储三个状态（pending，resolved，rejected），一旦发出请求了，<strong>必须闭环，无法取消</strong>，之前处于pending状态只是一个挂起请求的状态，并不是取消，一般不会让这种情况发生，只是用来临时中止链式的进行。</p>
<p>中断（终止）的本质在链式中只是挂起，并不是本质的取消<code>Promise</code>请求，那样是做不到的，<code>Promise</code>也没有<code>cancel</code>的状态。</p>
<p>不同于<code>Promise</code>的链式写法，写在async/await中想要中断程序就很简单了，因为语义化非常明显，其实就和一般的<code>function</code>写法一样，想要中断的时候，直接<code>return</code>一个值就行，<code>null</code>，空，<code>false</code>都是可以的。看例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> demo = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> setDelay(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> setDelaySecond(count);</span><br><span class="line">  <span class="built_in">console</span>.log(result1);</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">5</span>) &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="string">&#x27;我退出了，下面的不进行了&#x27;</span>;</span><br><span class="line">    <span class="comment">// return; </span></span><br><span class="line">    <span class="comment">// return false; // 这些写法都可以</span></span><br><span class="line">    <span class="comment">// return null;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> setDelay(<span class="number">1000</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成了&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">demo().then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实质就是直接<code>return</code>返回了一个<code>Promise</code>，相当于<code>return Promise.resolve(&#39;我退出了下面不进行了&#39;)</code>，当然你也可以返回一个“拒绝”：<code>return Promise.reject(new Error(&#39;拒绝&#39;))</code>那么就会进到错误信息里去。</p>
<p><em><strong>async函数实质就是返回一个Promise！</strong></em></p>
<h2 id="实战中异步需要注意的地方"><a href="#实战中异步需要注意的地方" class="headerlink" title="实战中异步需要注意的地方"></a>实战中异步需要注意的地方</h2><p>我们经常会使用上述两种写法，也可能混用，有时候会遇到一些情况，这边举例子说明：</p>
<h3 id="Promise获取数据-串行-之then写法注意"><a href="#Promise获取数据-串行-之then写法注意" class="headerlink" title="Promise获取数据(串行)之then写法注意"></a>Promise获取数据(串行)之then写法注意</h3><p>并行的不用多说，很简单，直接循环发出请求就可以或者用<code>Promise.all</code>。如果我们需要串行循环一个请求，那么应该怎么做呢？</p>
<p>我们需要实现<strong>一个依次分别延迟1秒输出值，一共5秒的程序</strong>，首先是Promise的循环，这个循环就相对来说比较麻烦：</p>
<p><em><strong>我们经常会犯的错误！就是不重视函数名与函数执行对程序的影响</strong></em></p>
<p>先不说循环，我们先举一个错误的例子，现在有一个延迟函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setDelay = <span class="function">(<span class="params">millisecond</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> millisecond != <span class="string">&#x27;number&#x27;</span>) reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;参数必须是number类型&#x27;</span>));</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">`我延迟了<span class="subst">$&#123;millisecond&#125;</span>毫秒后输出的`</span>)</span><br><span class="line">      &#125;, millisecond)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想做到：<strong>“循环串行执行延迟一秒的Promise函数”</strong>，期望的结果应该是：隔一秒输出<code>我延迟了1000毫秒后输出的</code>，一共经过循环3次。我们想当然地写出下列的链式写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr = [setDelay(<span class="number">1000</span>), setDelay(<span class="number">1000</span>), setDelay(<span class="number">1000</span>)]</span><br><span class="line">arr[<span class="number">0</span>]</span><br><span class="line">.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">2</span>]</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是很不幸，<strong>你发现输出是并行的！！！也就是说一秒钟一次性输出了3个值！</strong>。那么这是什么情况呢？其实很简单。。。<strong>就是你把<code>setDelay(1000)</code>这个直接添加到数组的时候，其实就已经执行了，注意你的执行语句<code>(1000)</code></strong></p>
<p>这其实是基础，是语言的特性，很多粗心的人（或者是没有好好学习JS的人）会以为这样就把函数添加到数组里面了，殊不知函数已经执行过一次了。</p>
<p>那么这样导致的后果是什么呢？也就是说数组里面保存的每个<code>Promise</code>状态都是<code>resolve</code>完成的状态了，那么你后面链式调用直接<code>return arr[1]</code>其实没有去请求，只是<strong>立即返回了一个resolve的状态</strong>。所以你会发现程序是相当于并行的，没有依次顺序调用。</p>
<p>那么解决方案是什么呢？直接函数名存储函数的方式（不执行Promise）来达到目的</p>
<p>我们这样改一下程序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr = [setDelay, setDelay, setDelay]</span><br><span class="line">arr[<span class="number">0</span>](<span class="number">1000</span>)</span><br><span class="line">.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">1</span>](<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">2</span>](<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述相当于把<code>Promise</code>预先存储在一个数组中，在你需要调用的时候，再去执行。当然你也可以用闭包的方式存储起来，需要调用的时候再执行。</p>
<h3 id="Promise循环获取数据-串行-之for循环"><a href="#Promise循环获取数据-串行-之for循环" class="headerlink" title="Promise循环获取数据(串行)之for循环"></a>Promise循环获取数据(串行)之for循环</h3><p>上述写法是不优雅的，次数一多就GG了，为什么要提一下上面的<code>then</code>，其实就是为了后面的<code>for</code>循环做铺垫。</p>
<p>上面的程序根据规律改写一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr = [setDelay, setDelay, setDelay]</span><br><span class="line"><span class="keyword">var</span> temp</span><br><span class="line">temp = arr[<span class="number">0</span>](<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line">      temp.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;完成了&#x27;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = temp.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        <span class="keyword">return</span> arr[i](<span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中：原文中为<code>return arr[i-1](1000)</code>我改成了<code>return arr[i](1000)</code></p>
</blockquote>
<p>错误处理可以在for循环中套入<code>try...catch</code>，或者在你每个循环点进行<code>.then().catch()</code>、都是可行的。如果你想提取成公共方法，可以再改写一下，利用递归的方式：</p>
<p>首先你需要闭包你的<code>Promise</code>程序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">millisecond</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> setDelay(millisecond);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不闭包会导致什么后果呢？不闭包的话，你传入的参数值后，<strong>你的Promise会马上执行，导致状态改变</strong>，如果用闭包实现的话，你的Promise会一直保存着，等到你需要调用的时候再使用。而且<strong>最大的优点是可以预先传入你需要的参数</strong>。</p>
<p>改写数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr = [timeout(<span class="number">2000</span>), timeout(<span class="number">1000</span>), timeout(<span class="number">1000</span>)]</span><br></pre></td></tr></table></figure>

<p>提取方法，<code>Promise</code>数组作为参数传入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> syncPromise = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _syncLoop = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count === arr.length - <span class="number">1</span>) &#123; <span class="comment">// 是最后一个就直接return</span></span><br><span class="line">      <span class="keyword">return</span> arr[count]()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[count]().then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">      <span class="keyword">return</span> _syncLoop(count+<span class="number">1</span>) <span class="comment">// 递归调用数组下标</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _syncLoop(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">syncPromise(arr).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 或者 添加到Promise类中方法</span></span><br><span class="line"><span class="built_in">Promise</span>.syncAll = <span class="function"><span class="keyword">function</span> <span class="title">syncAll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> syncPromise</span><br><span class="line">&#125;<span class="comment">// 以后可以直接使用</span></span><br><span class="line"><span class="built_in">Promise</span>.syncAll(arr).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成了&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>还有大神总结了一个<code>reduce</code>的写法，其实就是一个迭代数组的过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = arr.reduce(<span class="function">(<span class="params">total, current</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        <span class="keyword">return</span> current()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;程序开始&#x27;</span>))</span><br><span class="line">p.then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;结束了&#x27;</span>, result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>都是可行的，在<code>Promise</code>的循环领域。</p>
<h3 id="async-await循环获取数据-串行-之for循环"><a href="#async-await循环获取数据-串行-之for循环" class="headerlink" title="async/await循环获取数据(串行)之for循环"></a>async/await循环获取数据(串行)之for循环</h3><p>现在就来介绍一下牛逼的async/await实战，上述的代码你是不是要看吐了，的确，我也觉得好麻烦啊，那么如果用<code>async/await</code>能有什么改进吗？这就是它出现的意义：</p>
<p>模拟上述代码的循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    arr = [timeout(<span class="number">2000</span>), timeout(<span class="number">1000</span>), timeout(<span class="number">1000</span>)]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		result = <span class="keyword">await</span> arr[i]();</span><br><span class="line">    	<span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>。。。这就完了？是的。。。就完了，是不是特别方便！！！！语义化也非常明显！！这里为了保持与上面风格一致，没有加入错误处理，所以实战的时候记得加入你的<code>try...catch</code>语句来捕获错误。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>一直想总结一下<code>Promise</code>和<code>async/await</code>，很多地方可能总结得不够，已经尽力扩大篇幅了，后续有新的知识点和总结点可能会更新（未完待续），但是入门这个基本够用了。</p>
<p>我们常说什么<code>async/await</code>的出现淘汰了Promise，可以说是大错特错，恰恰相反，正因为有了Promise，才有了改良版的<code>async/await</code>，从上面分析就可以看出，两者是相辅相成的，缺一不可。</p>
<p>想学好<code>async/await</code>必须先精通<code>Promise</code>，两者密不可分，有不同意见和改进的欢迎指导！</p>
<p>前端小白，大家互相交流，peace！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">RouRouX</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rouroux.github.io/js-promise-async/">https://rouroux.github.io/js-promise-async/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rouroux.github.io">RouRouX's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javascript/">javascript</a><a class="post-meta__tags" href="/tags/promise/">promise</a><a class="post-meta__tags" href="/tags/async-await/">async/await</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/cross-domain-ajax/"><i class="fa fa-chevron-left">  </i><span>利用iframe实现ajax跨域通信的解决方案</span></a></div><div class="next-post pull-right"><a href="/js-and-or/"><span>javascript中逻辑运算(||，&amp;&amp;，!)</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/RouRouX/store/img/20200601011404.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By RouRouX</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>